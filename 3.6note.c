/*运算符分类
	一、基本运算符
		1.算术运算符
			运算符	运算规则	操作数数目	优先级	结合方向
			－		负号		单目		2		右结合
			＋		加法		双目		4		左结合
			－		减法		双目		4		左结合
			＊		乘法		双目		3		左结合
			／		除法		双目		3		左结合
			％		求余或模	双目		3		左结合		
			注意：	/	两个整数相除，必得整数，此为地板除。5/3 = 1;	3/5 = 0;
					分子式或分母式有一个是浮点数，那么结果就是浮点数。5.0/3 = 1.66666……;	
					%	用来计算两个整型数相除得到的余数。3%5 = 3;	12%5 = 2;
					两个数必须是整型量，其结果也是整型量
					m%n值的范围[0,n-1]
		2.赋值运算符
			+=	-= *=	/=	%=	^=	|=	&=	<<=	>>=
		3.逗号运算符
			,	逗号表达式
		4.逻辑运算符
			&&	逻辑与	两端都要成立
			||	逻辑或	两端成立一个就行
			!	逻辑非	0为假，非0为真，取反	！假 = 真，！真 = 假
			运算规则：
			& 无论左边结果是什么，右边还是继续运算；
			&& 当左边为假，右边不再进行运算。
				同理，||与|也是如此
		5.条件运算符
			>	<	>=	<=	==	!=
		6.求字节运算符
			sizeof
		7.自增自减运算符
			1）	含义	运算符	优先级	结合性	功能
				自增	++		2		右结合	使变量的值增1
				自减	--		2		右结合	使变量的值减1
				使用形式	? ++i 或--i  变量i先自增或自减1,再引用i。
				i++或i--   先使用变量i,再自增或自减1。 
				如：short int a = 3;
					a ++;					//自增1
					printf("%hd",a);	4	//short int对应"%hd"	long int对应"%ld"
					a --;					//自减1
					a ++;
					a ++;
					printf("%hd",a);	5
					a=2;
					++a + a++ = 6			//前者先自增后赋值，后者先赋值后自增
					3	+3		a=4;	
					具体参考：F:\C\day9\自增自减.c
			2）注意：
			I.自增、自减运算只能用于变量, 不能用于常量和表达式。
			II.自增、自减运算符是两个+或两个-的一个整体, 中间不能有空格。
				如果有多于两个+ 或两个-连写的情况，
				则编译首先识别前两个+或-为增量或减量运算符。
			III.表达式 x+++y 等价于 (x++)+y
				自增、自减运算符的运算顺序是右结合，
				因此对-i++应理解为:-(i++)，而 (-i )++ 是非法的。
				例:      i=3 ;
					printf("%d", -i++);    输出:-3

	二、位运算符
		1.位逻辑运算符
			&	按位与 如果两个相应的二进制位都为1，则该位的结果值为1，否则为0
			|	按位或 两个相应的二进制位中只要有一个为1，该位的结果值为1
			^	按位异或 若参加运算的两个二进制位值相同则为0，否则为1
		2.位自反运算符
			~	取反 ~是一元运算符，用来对一个二进制数按位取反，即将0变1，将1变0
		3.位移动运算符
			<<（N）	左移运算 用来将一个数的各二进制位全部左移N位，右补0		左移N位等于原数*2^N
			>>（N）	右移运算 将一个数的各二进制位右移N位，移到右端的低位被舍弃，对于无符号数，高位补0	左移N位等于原数/2^N
	三、特殊运算符
		1.强制类型转换（类型）
		2.指针运算符：*	&
		3.下标运算符：[]
		4.分量运算符：->
		
	-------------------------------------------------------------
		原文：https://blog.csdn.net/Gordennizaicunzai/article/details/52557270
*/

/*表达式
	在C程序中, 当不同类型的量进行运算时, 要转换成同一种类型然后再进行运算。
		转换方式:   
			自动转换：数据类型自动由低级向高级转换。
				自动类型转换：低精度——>高精度
			强制转换:  将表达式的运算结果强制转换成指定的数据类型。
				格式:
					（数据类型说明符）（表达式）
				注意:
					强制转换属单目运算, 运算优先级为2。
					强制转换得到的是中间结果类型，原变量类型不变。
					数据类型说明符和表达式都必须加括号(单个变量除外)
					强制转换
					warning C4244: '=' : conversion from 'double ' to 'float ', possible loss of data
					给S = (a + b) * h / 2.0;加(float)以及括号进行强制转换
					printf("面积为%f\n",S);		float对应"%f"	double对应"%lf"	小数点取2位，写".2f"，保留几位写几
			F:\C\day2\ave.c对强制转换有详细解释
	关系运算（比较运算）：< <= >= > != ==
			即比较两个量的大小, 比较的结果为"真"或"假"。
		关系表达式：用关系运算符将两个表达式连接起来的式子。
			格式:
				<表达式1> <关系运算符> <表达式2>
			其中:   表达式1和表达式2可以是任意表达式。
		关系表达式只能表达简单的关系，只能对一个条件进行测试
		sum>=1500	y!=z
	逻辑运算：！ && ||
			用逻辑运算符将表达式连接起来的式子。
		形式:
			[<表达式1>] <逻辑运算符> <表达式2>
			表达式1和表达式2可以是任何表达式
			判断时, 0代表"假", 非0即表示"真" 
    ( )→!→算术运算→关系运算→&&→||→赋值运算
		逻辑与和逻辑或运算符具有短路能力
			逻辑与:   (表达式1) && (表达式2) && … 
				只有表达式1的值为"真"时才求表达式2的值
			逻辑或:  (表达式1) || (表达式2) ||…
				只有表达式1为假时才判断表达式2的值
	条件运算：条件运算符:  ?  : 
			三目运算符、右结合、13级。
		条件表达式:
        	<表达式1> ? <表达式2> : <表达式3>
		条件运算符可以嵌套,  这种嵌套是右结合的。
	赋值运算：
		简单赋值运算符: =
		复合赋值运算符:  如 +=、-=、*=、/=、%= 等
		优先级14，右结合性。
		赋值表达式:  由赋值运算符连接起来式子
				作用:  将表达式的值赋给变量
			简单赋值运算符为"=" ; 由"="连接的式子为 (简单) 赋值表达式。
				格式:    <变量> = <表达式>     
				作用:   把右边表达式的值，赋给左边的变量。
				执行顺序是:  先计算，再赋值
			赋值运算的类型转换,  规则为:
				实型数据赋给整型变量时，只取整数部分。
				整型数据赋给实型变量时，以浮点形式取值。
				字符型数据赋给整型变量时, 整型变量的高位补的数与char的最高位相同,  低八位为字符的ASCII码值。
				整型数据赋给字符型时，只把低8位赋给字符变量。
		复合赋值符及表达式：
			复合赋值运算符是在简单赋值运算符前加双目运算符构成。 
			共10种: +=, -= *=、/=、%= 等。
	逗号运算符运算符:  " , "	优先级15级  最低，左结合
		用逗号运算符将各表达式连接起来的式子为逗号表达式。
			格式:<表达式1> , <表达式2> , … , <表达式n> 
			求解过程: 先求表达式1的值,再求表达式2的值,最后求表达式n的值,表达式n的值作为整个逗号表达式的值。
		说明：用一个逗号表达式语句，可代替多个赋值语句, 如
			a=0; b=1; c=2;    可写成:    a=0, b=1, c=2 ; 
			在变量说明和函数参数表中逗号只是起分隔符作用       
                printf("%d,%d,%d" , a , b ,c );
				printf("%d,%d,%d" , (a, b, c) , b ,c);
			printf 从右往左执行
				前置++、-- 即时执行，后置++、--printf命令执行完后才执行。
				这个结果是不确定的，因为不同的编译器计算表达式的顺序是不同的!
*/

/*#include<stdio.h>		//自增自减运算
void main()
{
	short int a = 3;
	a ++;					//i++ 或 i--	先使用变量i,再自增或自减1
	printf("%hd\n",a);	//4	//short int对应"%hd"	long int对应"%ld"
	a --;					//++i 或 --i  	变量i先自增或自减1,再引用i
	a ++;	1）				自增、自减运算只能用于变量, 不能用于常量和表达式。
			2）			自增、自减运算符是两个+或两个-的一个整体, 中间不能有空格。
			3）			如果有多于两个+ 或两个-连写的情况，则编译首先识别前两个+或-为增量或减量运算符。
			4）			表达式 x+++y 等价于 (x++)+y
			5）	自增、自减运算符的运算顺序是右结合，因此对-i++应理解为:   -(i++)，而 (-i )++ 是非法的。
	a ++;
	printf("%hd\n",a);	//5
}*/
/*#include<stdio.h>		//float与double
void main()
{
	int a = 0;
	int b = 0;
	int h = 0;					1,2用来区分分别用double和float算法的不同
	
2	double S = 0;
2	S = (a + b) * h / 2.0;		写2.0遵循（分子式或分母式有一个是浮点数，那么结果就是浮点数。）原则
2	printf("面积为%lf\n",S);	

1	float S = 0;
	printf("请输入上底，下底，高的值：");
	scanf("%d%d%d",&a,&b,&h);
1	S = (float)((a + b) * h / 2.0);
//	强制转换
//	warning C4244: '=' : conversion from 'double ' to 'float ', possible loss of data
//	给S = (a + b) * h / 2.0;加(float)以及括号进行强制转换
1	printf("面积为%f\n",S);		//float对应"%f"	double对应"%lf"	小数点取2位，写".2f"，保留几位写几
}
*/
//F:\C\day2\ave.c对强制转换有详细解释
#include<stdio.h>
void main()
{
	int age = 0;
	while(1)		//while后不加;
	{
		printf("请输入您的年龄：");
		scanf("%d",&age);
		printf("您输入的年龄：%d\n",age);
		if(age <= 0)
		{
			printf("您的年龄输入有误\n");
		}
		else if(age < 20)
		{
			printf("您还很年轻\n");
		}
		else if(age < 30)
		{
			printf("您的年龄古称弱冠\n");
		}
		else if(age < 40)
		{
			printf("您的年龄古称而立\n");
		}
		else if(age < 50)
		{
			printf("您的年龄古称不惑\n");
		}
		else if(age < 60)
		{
			printf("您的年龄古称知天命\n");
		}
		else if(age < 70)
		{
			printf("您的年龄古称花甲\n");
		}
		else if(age < 80)
		{
			printf("您的年龄古称古稀\n");
		}
		else if(age < 100)
		{
			printf("您的年龄古称耄耋\n");
		}
		else	
		{
			printf("您的年龄古称期颐\n");
		}
	}
}

/*原码，反码，补码
	~自反符号位也取反，取反符号位不变
	正数自反运算：求原码，然后自反，然后-1得到反码，取反得到原码
	负数自反运算：求原码，求补码，然后对补码进行自反，即得到原码
	具体参考：F:\C\day6\6.c
	在计算机内，有符号数有3种表示法：原码、反码和补码。
	正数以原码存储，负数以补码存储
	所有数据的运算都是采用补码进行的。
原码：原码就是符号位加上真值的绝对值，即最高位为符号位，“0”表示正，“1”表示负，其余位表示数值的大小。
	+3 = 00000011
	-3 = 10000011
反码：正数的反码与其原码相同；负数的反码是对其原码逐位取反，但符号位除外。
	+3 = 00000011
    -3 = 11111100
补码：正数的补码与其原码相同；负数的补码是在其反码的末位加1，符号位不变。
	+3 = 00000011
	-3 = 11111101
*/

/*乘方开方的使用
		
		x为底数，y为指数
		
		pow(x,y)	//双精度乘方
		
		float powf(float x, float y); //单精度乘方

		long double powl(long double x, long double y); //长双精度乘方

		double sqrt(double x);  //双精度开方

		float sqrtf(float x);         //单精度开方

		long double sqrtl(long double x);   //长双精度开方
		
		具体参考：F:\C\execrise\13.c
--------------------- 
作者：无止境x 
来源：CSDN 
原文：https://blog.csdn.net/xjp_xujiping/article/details/55212832 

*/

/*内存分区：
	1.堆区：人为产生，人为释放
	2.栈区：就是那些由编译器在需要的时候分配，在不需要的时候自动清楚的变量的存储区。\
	里面的变量通常是局部变量、函数参数等自动产生，自动释放（形式参数，局部变量）
	3.常量文本区：程序执行常量文本代码时产生，程序结束时由操作系统释放
	4.全局区：全局变量
	5.程序代码区：if else等

*/

/*库函数：
	1.strlen
		1）功能：能测出从某个字符型内存块的地址开始，截止到第一个'\0'，
		中间字符的个数（不含'\0'）
		2）函数原型：unsigned int mystrlen(const char* a)
	2.atoi
	3.iota
	3.const	
		
		具体参考：F:\C\day10\atoi.c


*/

/*白盒测试：
	1.要求全覆盖
	2.软件开发质量
		1）等价类划分
		2）边界值测试
	3.遵守研发流程

*/

/*内存分区
						生存周期						相关							动/静	
	栈				使用时创建，使用完毕由内存释放		与函数相关						动态存储			先进后出
	堆				手动创建，由程序员手动释放			malloc，free					静态存储			先进先出
	全局/静态		编译时创建，程序结束释放			全局变量，字符串常量，静态常量		静态存储	
	程序代码区		编译时创建，程序结束释放				代码						静态存储	
			

*/

/*泄露溢出
	内存泄漏（Memory Leak）
		是指程序中己动态分配的堆内存由于某种原因程序未释放或无法释放，
		造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果
	内存溢出（out of memory）
		通俗理解就是内存不够，通常在运行大型软件或游戏时，软件或游戏所需要的内存远远超出
		了你主机内安装的内存所承受大小，就叫内存溢出。此时软件或游戏就运行不了，
		系统会提示内存溢出，有时候会自动关闭软件，重启电脑或者软件后释放掉一部分内存又可以正常运行该软件
	堆栈溢出
		就是不顾堆栈中数据块大小，向该数据块写入了过多的数据，导致数据越界，结果覆盖了老的堆栈数据。
		（百度官方解释：栈溢出是由于C语言系列没有内置检查机制来确保复制到缓冲区的数据不得大于缓冲区的大小，
		因此当这个数据足够大的时候，将会溢出缓冲区的范围）。

	踩内存
		访问了不该访问的地址，尤其在c指针中，可以访问不合法的内存。
*/

/*	#include<math.h>
	#include<stdio.h>
	void main()
	{
		int x = 0;
		printf("请输入：\n");
		scanf("%d",&x);
		printf("\n");
	}


*/


